<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IO List Code Generator</title>

  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <style>
    body { font-family: Arial, sans-serif; max-width: 1400px; margin: 0 auto; padding: 16px; }
    .topbar { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; margin-bottom: 12px; }
    .pill { background: #f0f3ff; border: 1px solid #d7defc; padding: 3px 10px; border-radius: 999px; font-size: 12px; }
    .muted { color: #555; font-size: 12px; }
    .row { display: flex; gap: 16px; align-items: flex-start; }
    .col { flex: 1; min-width: 320px; }
    .box { border: 1px solid #ddd; border-radius: 10px; padding: 12px; }
    textarea { width: 100%; box-sizing: border-box; font-family: Consolas, "Courier New", monospace; }
    pre { background: #f6f6f6; padding: 10px; border-radius: 8px; overflow: auto; }
    h1 { margin: 0 0 8px 0; }
    h3, h4 { margin: 10px 0 6px 0; }
    .boxHeader { display: flex; justify-content: space-between; align-items: center; gap: 10px; }
    .copyBtn { padding: 6px 10px; border: 1px solid #cfcfcf; border-radius: 8px; background: #fff; cursor: pointer; }
    .copyBtn:active { transform: translateY(1px); }
  </style>
</head>

<body>
  <div id="app">
    <h1>IO list code generator</h1>

    <div class="topbar">
      <input type="file" @change="onFile" accept=".xlsx,.xls,.xlsm" />
      <span class="pill">Header row (1-based): {{ headerRowNumber }}</span>
      <span class="pill">Sheet: {{ usedSheetName || '-' }}</span>
      <span class="pill">Tags: {{ tags.length }}</span>
      <span class="pill">Digital alarms: {{ alarmDigitalLinesCount }}</span>
      <span class="pill">Analog alarms: {{ alarmAnalogLinesCount }}</span>
      <span class="muted">Requires columns: NAME, Alarm</span>
    </div>

    <div class="box">
      <div class="boxHeader">
        <h3 style="margin:0;">IO_Tags (GVL)</h3>
		  <div style="display:flex; gap:8px;">
			<button class="copyBtn" @click="copyText(tagsText, 'IO_Tags')">Copy</button>
			<button class="copyBtn" @click="downloadXmlIO()">Create IO_Tags.xml</button>
		  </div>
      </div>
      <textarea v-model="tagsText" rows="10" readonly></textarea>
    </div>

    <!-- Alarm_tags (single box for GVL) -->
    <div class="box" style="margin-top: 16px;">
      <div class="boxHeader">
        <h3 style="margin:0;">Alarm_tags (GVL)</h3>
        <div style="display:flex; gap:8px;">
			<button class="copyBtn" @click="copyText(alarmTagsText, 'Alarm_tags')">Copy</button>
			<button class="copyBtn" @click="downloadXmlAlarm()">Create Alarm_tags.xml</button>
	    </div>
      </div>
      <textarea v-model="alarmTagsText" rows="16" readonly></textarea>
    </div>

    <!-- TwinCAT: split in 2 boxes (Declarations + Program) -->
    <div class="row" style="margin-top: 16px;">
      <div class="col box">
        <div class="boxHeader">
          <h3 style="margin:0;">Alarms (Declarations)</h3>
          <button class="copyBtn" @click="copyText(alarmsTwinCatDeclaration, 'Alarms Declarations')">Copy</button>
        </div>
        <textarea v-model="alarmsTwinCatDeclaration" rows="22" readonly></textarea>
      </div>

      <div class="col box">
        <div class="boxHeader">
          <h3 style="margin:0;">Alarms (Program)</h3>
          <button class="copyBtn" @click="copyText(alarmsTwinCatProgram, 'Alarms Program')">Copy</button>
        </div>
        <textarea v-model="alarmsTwinCatProgram" rows="22" readonly></textarea>
      </div>
    </div>
	
	<div class="box" style="margin-top: 16px">
	  <div class="boxHeader">
		<h3 style="margin:0">Alarms (.tmc)</h3>
		<div style="display:flex; gap:8px">
		  <button class="copyBtn" @click="copyText(tmcText, 'Alarms.tmc Copy')">Copy</button>
		  <button class="copyBtn" @click="downloadTmc()">Create Alarms.tmc</button>
		</div>
	  </div>
	  <textarea v-model="tmcText" rows="16" readonly></textarea>
	</div>
	
	<div class="box" style="margin-top: 16px">
	  <div class="boxHeader">
		<h3 style="margin:0">VariableScale (Program)</h3>
		<button class="copyBtn" @click="copyText(variableScalingProgram, 'VariableScale')">Copy</button>
	  </div>
	  <textarea v-model="variableScalingProgram" rows="18" readonly></textarea>
	</div>

    <h3 style="margin-top: 16px;">Debug</h3>
    <pre>{{ debug }}</pre>
  </div>

  <script>
    const { createApp } = Vue;

    createApp({
      data() {
		return {
          // Settings
          headerRowNumber: 10,
          preferredSheetName: 'IO-list',

          // Runtime
          usedSheetName: '',
          rows: [],
      
		  // NEW: máximos para el XML de Alarm_tags
		  maxID: null,
		  maxIDA: null,
	  
          // Outputs
          tags: [],
          tagsText: '',
          alarmDigitalText: '',
          alarmAnalogText: '',
          alarmTagsText: '',
          alarmsTwinCatDeclaration: '',
          alarmsTwinCatProgram: '',
		  variableScalingProgram: '',
          debug: '',
		  
		  // For Alarms.tmc
		  tmcText: '',
		tmcDigitalEventsText: '',
		tmcAnalogEventsText: '',

		  tplTmcHeader:
		  `<?xml version="1.0"?>\n` +
		  `<TcModuleClass>\n` +
		  `\t<DataTypes>\n` +
		  `\t\t<DataType>\n` +
		  `\t\t\t<Name GUID="{F35E4D12-5B8B-4C8F-95D2-0AE92108A152}">AlarmClass</Name>\n` +
		  `\t\t\t<DisplayName TxtId=""><![CDATA[Alarms]]></DisplayName>`,
		  
		  tplTmcFooter:
		  `\t\t\t<Hides>\n` +
		  `\t\t\t\t<Hide GUID="{E7B8BF09-DA2F-43D9-8251-4C214D77CFBB}"/>\n` +
		  `\t\t\t\t<Hide GUID="{CBF90603-C429-49C1-92C4-454EBD10F716}"/>\n` +
		  `\t\t\t\t<Hide GUID="{42EEBECA-5185-42BE-8389-5A7DA26A926F}"/>\n` +
		  `\t\t\t\t<Hide GUID="{21017743-398E-4446-8129-0925ADC15AD9}"/>\n` +
		  `\t\t\t\t<Hide GUID="{390EA75C-CC63-4FC5-9B03-1A06C29A2A30}"/>\n` +
		  `\t\t\t\t<Hide GUID="{551E4D89-E3A8-4642-B7A6-77482930F8C8}"/>\n` +
		  `\t\t\t\t<Hide GUID="{CA4CA1EF-B7E4-43CB-8D79-D140B03E196E}"/>\n` +
		  `\t\t\t\t<Hide GUID="{BD7EAD56-F85A-434F-BC76-EA84C4194656}"/>\n` +
		  `\t\t\t\t<Hide GUID="{5BE57882-1887-4DC6-A745-62AE0883584B}"/>\n` +
		  `\t\t\t\t<Hide GUID="{8BBF7EC2-E5D4-44E6-B5BF-C7CDA821DCCC}"/>\n` +
		  `\t\t\t\t<Hide GUID="{B6CAB811-BEF3-4E23-B0B4-9381B807F4C7}"/>\n` +
		  `\t\t\t\t<Hide GUID="{43FFCBA6-5F44-43ED-9771-FB96E54B41CD}"/>\n` +
		  `\t\t\t\t<Hide GUID="{AF1B25DF-6DE6-4A41-8105-FABBE55412B5}"/>\n` +
		  `\t\t\t\t<Hide GUID="{DC81660B-BCFD-45D8-932F-18A29A2DB34C}"/>\n` +
		  `\t\t\t\t<Hide GUID="{B2B6336A-1BAA-4CC3-960F-F398DB7EAD14}"/>\n` +
		  `\t\t\t\t<Hide GUID="{AC3C0553-739E-43F7-B723-0B5692D67F4F}"/>\n` +
		  `\t\t\t\t<Hide GUID="{3A5B0D97-C9A0-4EFE-90D0-92D148DF41AD}"/>\n` +
		  `\t\t\t\t<Hide GUID="{4A6C504E-0A05-4046-BF0B-BCBC5903E5D3}"/>\n` +
		  `\t\t\t\t<Hide GUID="{0E8410E7-FFF7-4B2F-8DFE-3C501CCD38E6}"/>\n` +
		  `\t\t\t\t<Hide GUID="{A23DB3C7-DA7F-48C6-B9B8-188165D24202}"/>\n` +
		  `\t\t\t\t<Hide GUID="{1C918F25-D9E1-47DC-99F5-41179C9E0E7A}"/>\n` +
		  `\t\t\t\t<Hide GUID="{4E02245A-FA0B-4E1A-8E68-C5DAD38BD585}"/>\n` +
		  `\t\t\t\t<Hide GUID="{92789ACA-75D3-4964-B159-1F23A113C540}"/>\n` +
		  `\t\t\t\t<Hide GUID="{F324088C-1E2B-436A-ABBB-168FC6F6D393}"/>\n` +
		  `\t\t\t\t<Hide GUID="{F77806D3-4A13-4580-80D7-8D9C364E1BD1}"/>\n` +
		  `\t\t\t</Hides>\n` +
		  `\t\t</DataType>\n` +
		  `\t</DataTypes>\n` +
		  `</TcModuleClass>`,
		  
		  tplXmlIOTags: `<?xml version="1.0" encoding="utf-8"?>
		  <project xmlns="http://www.plcopen.org/xml/tc6_0200">
		  <fileHeader companyName="Beckhoff Automation GmbH" productName="TwinCAT PLC Control" productVersion="3.5.20.60" creationDateTime="2026-02-19T13:40:53.8672332" />
		  <contentHeader name="Untitled1" modificationDateTime="2026-02-19T13:40:53.8717493">
			<coordinateInfo>
			  <fbd>
				<scaling x="1" y="1" />
			  </fbd>
			  <ld>
				<scaling x="1" y="1" />
			  </ld>
			  <sfc>
				<scaling x="1" y="1" />
			  </sfc>
			</coordinateInfo>
			<addData>
			  <data name="http://www.3s-software.com/plcopenxml/projectinformation" handleUnknown="implementation">
				<ProjectInformation />
			  </data>
			</addData>
		  </contentHeader>
		  <types>
			<dataTypes />
			<pous />
		  </types>
		  <instances>
			<configurations />
		  </instances>
		  <addData>
			<data name="http://www.3s-software.com/plcopenxml/globalvars" handleUnknown="implementation">
			  <globalVars name="IO_Tags">
				<addData>
				  <data name="http://www.3s-software.com/plcopenxml/attributes" handleUnknown="implementation">
					<Attributes>
					  <Attribute Name="global_init_slot" Value="40500" />
					</Attributes>
				  </data>
				  <data name="http://www.3s-software.com/plcopenxml/buildproperties" handleUnknown="implementation">
					<BuildProperties>
					  <LinkAlways>true</LinkAlways>
					</BuildProperties>
				  </data>
				  <data name="http://www.3s-software.com/plcopenxml/interfaceasplaintext" handleUnknown="implementation">
					<InterfaceAsPlainText>
					  <xhtml xmlns="http://www.w3.org/1999/xhtml">{attribute 'global_init_slot' := '40500'}
VAR_GLOBAL
// Insert code here
END_VAR</xhtml>
					</InterfaceAsPlainText>
				  </data>
				  <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
					<ObjectId>b57b3cc8-481e-47d2-932e-c1d070231dc5</ObjectId>
				  </data>
				</addData>
			  </globalVars>
			</data>
			<data name="http://www.3s-software.com/plcopenxml/projectstructure" handleUnknown="discard">
			  <ProjectStructure>
				<Object Name="IO_Tags" ObjectId="b57b3cc8-481e-47d2-932e-c1d070231dc5" />
			  </ProjectStructure>
			</data>
		  </addData>
		</project>`,
		  
		  	tplXmlAlarmTags: `<?xml version="1.0" encoding="utf-8"?>
			<project xmlns="http://www.plcopen.org/xml/tc6_0200">
			  <fileHeader companyName="Beckhoff Automation GmbH" productName="TwinCAT PLC Control" productVersion="3.5.20.60" creationDateTime="2026-02-19T13:41:07.4111748" />
			  <contentHeader name="Untitled1" modificationDateTime="2026-02-19T13:41:07.4111748">
				<coordinateInfo>
				  <fbd>
					<scaling x="1" y="1" />
				  </fbd>
				  <ld>
					<scaling x="1" y="1" />
				  </ld>
				  <sfc>
					<scaling x="1" y="1" />
				  </sfc>
				</coordinateInfo>
				<addData>
				  <data name="http://www.3s-software.com/plcopenxml/projectinformation" handleUnknown="implementation">
					<ProjectInformation />
				  </data>
				</addData>
			  </contentHeader>
			  <types>
				<dataTypes />
				<pous />
			  </types>
			  <instances>
				<configurations />
			  </instances>
			  <addData>
				<data name="http://www.3s-software.com/plcopenxml/globalvars" handleUnknown="implementation">
				  <globalVars name="Alarm_tags" constant="true">
					<variable name="ArrMinD">
					  <type>
						<INT />
					  </type>
					  <initialValue>
						<simpleValue value="1" />
					  </initialValue>
					  <documentation>
						<xhtml xmlns="http://www.w3.org/1999/xhtml"> Digital alarm array size</xhtml>
					  </documentation>
					</variable>
					<variable name="ArrMaxD">
					  <type>
						<INT />
					  </type>
					  <initialValue>
						<simpleValue value="!!!'ERROR'!!!" />
					  </initialValue>
					</variable>
					<variable name="ArrMinA">
					  <type>
						<INT />
					  </type>
					  <initialValue>
						<simpleValue value="1" />
					  </initialValue>
					  <documentation>
						<xhtml xmlns="http://www.w3.org/1999/xhtml"> Analog alarm array size</xhtml>
					  </documentation>
					</variable>
					<variable name="ArrMaxA">
					  <type>
						<INT />
					  </type>
					  <initialValue>
						<simpleValue value="!!!'ERROR'!!!" />
					  </initialValue>
					</variable>
					<variable name="Arr_AlarmDigital">
					  <type>
						<array>
						  <dimension lower="ArrMinD" upper="ArrMaxD" />
						  <baseType>
							<derived name="ST_ALARM_DI" />
						  </baseType>
						</array>
					  </type>
					  <documentation>
						<xhtml xmlns="http://www.w3.org/1999/xhtml"> Array needs to be at least as big as the highest digital struct ID</xhtml>
					  </documentation>
					</variable>
					<variable name="Arr_AlarmAnalog">
					  <type>
						<array>
						  <dimension lower="ArrMinA" upper="ArrMaxA" />
						  <baseType>
							<derived name="ST_ALARM_AI" />
						  </baseType>
						</array>
					  </type>
					  <documentation>
						<xhtml xmlns="http://www.w3.org/1999/xhtml"> Array needs to be at least as big as the highest analog struct ID</xhtml>
					  </documentation>
					</variable>
					<addData>
					  <data name="http://www.3s-software.com/plcopenxml/attributes" handleUnknown="implementation">
						<Attributes>
						  <Attribute Name="global_init_slot" Value="40502" />
						</Attributes>
					  </data>
					  <data name="http://www.3s-software.com/plcopenxml/buildproperties" handleUnknown="implementation">
						<BuildProperties>
						  <LinkAlways>true</LinkAlways>
						</BuildProperties>
					  </data>
					  <data name="http://www.3s-software.com/plcopenxml/interfaceasplaintext" handleUnknown="implementation">
						<InterfaceAsPlainText>
						  <xhtml xmlns="http://www.w3.org/1999/xhtml">{attribute 'global_init_slot' := '40502'}
VAR_GLOBAL CONSTANT
	// Digital alarm array size
	ArrMinD: INT := 1;
	ArrMaxD: INT := __MAX_ID__;
	// Analog alarm array size
	ArrMinA: INT := 1;
	ArrMaxA: INT := __MAX_IDA__;
END_VAR

VAR_GLOBAL
	// Array needs to be at least as big as the highest digital struct ID
	Arr_AlarmDigital: ARRAY[ArrMinD..ArrMaxD] OF ST_ALARM_DI;
	// Array needs to be at least as big as the highest analog struct ID
	Arr_AlarmAnalog: ARRAY[ArrMinA..ArrMaxA] OF ST_ALARM_AI;
END_VAR

VAR_GLOBAL PERSISTENT
	// Insert code here
END_VAR</xhtml>
						</InterfaceAsPlainText>
					  </data>
					  <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
						<ObjectId>c33b50e5-b5f9-493f-a74a-119256a28240</ObjectId>
					  </data>
					  <data name="http://www.3s-software.com/plcopenxml/mixedattrsvarlist" handleUnknown="implementation">
						<MixedAttrsVarList>
						  <globalVars name="Alarm_tags" constant="true">
							<variable name="ArrMinD">
							  <type>
								<INT />
							  </type>
							  <initialValue>
								<simpleValue value="1" />
							  </initialValue>
							  <documentation>
								<xhtml xmlns="http://www.w3.org/1999/xhtml"> Digital alarm array size</xhtml>
							  </documentation>
							</variable>
							<variable name="ArrMaxD">
							  <type>
								<INT />
							  </type>
							  <initialValue>
								<simpleValue value="!!!'ERROR'!!!" />
							  </initialValue>
							</variable>
							<variable name="ArrMinA">
							  <type>
								<INT />
							  </type>
							  <initialValue>
								<simpleValue value="1" />
							  </initialValue>
							  <documentation>
								<xhtml xmlns="http://www.w3.org/1999/xhtml"> Analog alarm array size</xhtml>
							  </documentation>
							</variable>
							<variable name="ArrMaxA">
							  <type>
								<INT />
							  </type>
							  <initialValue>
								<simpleValue value="!!!'ERROR'!!!" />
							  </initialValue>
							</variable>
						  </globalVars>
						  <globalVars name="Alarm_tags">
							<variable name="Arr_AlarmDigital">
							  <type>
								<array>
								  <dimension lower="ArrMinD" upper="ArrMaxD" />
								  <baseType>
									<derived name="ST_ALARM_DI" />
								  </baseType>
								</array>
							  </type>
							  <documentation>
								<xhtml xmlns="http://www.w3.org/1999/xhtml"> Array needs to be at least as big as the highest digital struct ID</xhtml>
							  </documentation>
							</variable>
							<variable name="Arr_AlarmAnalog">
							  <type>
								<array>
								  <dimension lower="ArrMinA" upper="ArrMaxA" />
								  <baseType>
									<derived name="ST_ALARM_AI" />
								  </baseType>
								</array>
							  </type>
							  <documentation>
								<xhtml xmlns="http://www.w3.org/1999/xhtml"> Array needs to be at least as big as the highest analog struct ID</xhtml>
							  </documentation>
							</variable>
						  </globalVars>
						</MixedAttrsVarList>
					  </data>
					</addData>
				  </globalVars>
				</data>
				<data name="http://www.3s-software.com/plcopenxml/projectstructure" handleUnknown="discard">
				  <ProjectStructure>
					<Object Name="Alarm_tags" ObjectId="c33b50e5-b5f9-493f-a74a-119256a28240" />
				  </ProjectStructure>
				</data>
			  </addData>
		  </project>`
		  };
      },

      computed: {
        alarmDigitalLinesCount() {
          return (this.alarmDigitalText || '').split('\n').filter(l => l.trim()).length;
        },
        alarmAnalogLinesCount() {
          return (this.alarmAnalogText || '').split('\n').filter(l => l.trim()).length;
        }
      },

      methods: {
        onFile(e) {
          const file = e.target.files && e.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (evt) => {
            try {
              const data = new Uint8Array(evt.target.result);
              const wb = XLSX.read(data, { type: 'array' });

              const sheetName = wb.SheetNames.includes(this.preferredSheetName)
                ? this.preferredSheetName
                : wb.SheetNames[0];

              this.usedSheetName = sheetName;

              const ws = wb.Sheets[sheetName];
              this.rows = XLSX.utils.sheet_to_json(ws, {
			    header: 1,
			    blankrows: true,
			    defval: ''
			  });

              this.generateAll();
            } catch (err) {
              this.debug = `Error reading Excel: ${err && err.message ? err.message : String(err)}`;
            }
          };

          reader.readAsArrayBuffer(file);
        },

        async copyText(text, label = '') {
          const value = (text ?? '').toString();
          if (!value.trim()) {
            this.debug = `Nothing to copy${label ? ` (${label})` : ''}.`;
            return;
          }

          try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(value);
              this.debug = `✅ Copied${label ? ` (${label})` : ''}.`;
              return;
            }
          } catch (err) {
            // fall through
          }

          try {
            const ta = document.createElement('textarea');
            ta.value = value;
            ta.setAttribute('readonly', '');
            ta.style.position = 'fixed';
            ta.style.left = '-9999px';
            document.body.appendChild(ta);
            ta.focus();
            ta.select();
            ta.setSelectionRange(0, ta.value.length);
            document.execCommand('copy');
            document.body.removeChild(ta);
            this.debug = `✅ Copied${label ? ` (${label})` : ''} (fallback).`;
          } catch (err) {
            this.debug = `❌ Copy failed: ${err && err.message ? err.message : String(err)}`;
          }
        },
		
		// Add description
		xmlEscape(s) {
		  return String(s ?? '')
			.replace(/&/g, '&amp;')
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;');
		},
		
		downloadXmlIO() {
			const xml = this.buildIOTagsXml(this.tplXmlIOTags, this.tagsText);
			this.downloadTextFile(xml, 'IO_Tags.xml');
		},
		
		downloadXmlAlarm() {
		  const persistentST = [this.alarmDigitalText, this.alarmAnalogText]
			.filter(Boolean)
			.join('\n')
			.trimEnd();

		  const xml = this.buildAlarmTagsXml(
			this.tplXmlAlarmTags,
			persistentST, 
			this.maxID,
			this.maxIDA
		  );
			this.downloadTextFile(xml, 'Alarm_tags.xml');
		},
		
		
		buildIOTagsXml(templateXml, ioTagsStText) {
  return (templateXml ?? '').replace(
    '// Insert code here',
    this.xmlEscape((ioTagsStText ?? '').trimEnd())
  );
},

buildAlarmTagsXml(templateXml, persistentST, maxID, maxIDA) {
  let xml = String(templateXml ?? '');

  // Rellenar los __MAX_ID*__ del texto plano
  xml = xml.replace(/ArrMaxD\s*:\s*INT\s*:=\s*__MAX_ID__\s*;/g,  `ArrMaxD: INT := ${maxID};`);
  xml = xml.replace(/ArrMaxA\s*:\s*INT\s*:=\s*__MAX_IDA__\s*;/g, `ArrMaxA: INT := ${maxIDA};`);

  // Insertar ST en el marcador
  xml = xml.replace(
    '// Insert code here',
    this.xmlEscape((persistentST ?? '').trimEnd())
  );

  return xml;
},

		downloadTmc() {
		  const tmc = this.buildTmc(
			this.tplTmcHeader,
			this.tplTmcFooter,
			this.tmcDigitalEventsText,
			this.tmcAnalogEventsText
		  );

		  this.downloadTextFile(tmc, 'Alarms.tmc', 'application/xml');
		},

		buildTmc(tplHeader, tplFooter, digitalEventsText, analogEventsText) {
		  const digital = (digitalEventsText ?? '').trimEnd();
		  const analog  = (analogEventsText ?? '').trimEnd();

		  const middle =
			[digital, analog]
			  .filter(Boolean)
			  .join('\n');

		  return String(tplHeader ?? '') + middle + '\n' + String(tplFooter ?? '');
		},

		downloadTextFile(content, filename, mime='application/xml') {
		  const blob = new Blob([content], { type: mime });
		  const url = URL.createObjectURL(blob);
		  const a = document.createElement('a');
		  a.href = url;
		  a.download = filename;
		  a.click();
		  URL.revokeObjectURL(url);
		},
		
        generateAll() {
          // Helpers
          const toStrTrim = (v) => (v === null || v === undefined) ? '' : String(v).trim();

          const normalizeHeader = (s) =>
            toStrTrim(s)
              .toLowerCase()
              .replace(/\s+/g, ' ')
              .replace(/[^\w ]/g, '');

          const isAlarmMark = (v) => toStrTrim(v).toLowerCase() === 'x';
		
		const enToConfig = (v, defaultConfig) => {
		  const s = toStrTrim(v).toLowerCase();
		  if (!s) return '0';
		  if (s === 'x' || s === '1' || s === 'true') return defaultConfig; // enabled -> use AlarmConfig
		  // if the cell contains a number, use it directly as AlarmConfig for that threshold
		  const n = Number(s);
		  if (!Number.isNaN(n) && Number.isFinite(n)) return String(n);
		  return defaultConfig; // fallback
		  };

          const fmtNumberOrRaw = (v, fallback = '0') => {
            const s = toStrTrim(v);
            if (!s) return fallback;
            const n = Number(s);
            if (!Number.isNaN(n) && Number.isFinite(n)) return String(n);
            return s;
          };

          const toIdentifier = (s) => toStrTrim(s).replace(/[^\w]/g, '_');

          const pickSheetHeaderRowIndex = () => {
            const fixedIdx = Math.max(0, this.headerRowNumber - 1);
            const fixedRow = this.rows[fixedIdx] || [];
            const fixedNorm = fixedRow.map(normalizeHeader);

            if (fixedNorm.includes('name')) return fixedIdx;

            const maxScan = Math.min(this.rows.length, 50);
            for (let i = 0; i < maxScan; i++) {
              const r = this.rows[i] || [];
              const n = r.map(normalizeHeader);
              if (n.includes('name') && n.includes('alarm')) return i;
              if (n.includes('name')) return i;
            }
            return -1;
          };

          // Locate header row
          const headerRowIndex = pickSheetHeaderRowIndex();
          if (headerRowIndex === -1) {
            this.tags = [];
            this.tagsText = '';
            this.alarmDigitalText = '';
            this.alarmAnalogText = '';
            this.alarmTagsText = '';
            this.alarmsTwinCatDeclaration = '';
            this.alarmsTwinCatProgram = '';
            this.debug = `Header row not found. Expected row ${this.headerRowNumber} or a row containing NAME/Alarm.`;
            return;
          }

          const headerRaw = this.rows[headerRowIndex] || [];
          const headerNorm = headerRaw.map(normalizeHeader);
          const startDataIndex = headerRowIndex + 1;

          const col = {};
          headerNorm.forEach((h, i) => { if (h) col[h] = i; });

          // Required
          const dataRows = this.rows.slice(startDataIndex);
          const idxNAME = col['name'];
          const idxAlarm = col['alarm'];
		  const idxTYPE = col['type'];
		  const idxHMI = col['hmi'];

          if (idxNAME === undefined) {
            this.debug = `"NAME" column not found on header row ${headerRowIndex + 1}.`;
            return;
          }
          if (idxAlarm === undefined) {
            this.debug = `"Alarm" column not found on header row ${headerRowIndex + 1}.`;
            return;
          }
		  if (idxTYPE === undefined) {
		    this.debug = `"TYPE" column not found on header row ${headerRowIndex + 1}.`;
		    return;
		  }
		  if (idxHMI === undefined) {
		    this.variableScalingProgram = '';
		    this.debug += '\nHMI column not found.';
		  }
		
          // Columns for IO_Tags
          const idxHardwareDecl = col['hardware declaration'];
          const idxComment = col['comment'];
		  const idxControl = col['control'];

          // Columns for alarms
          const idxALMNAME = col['alm name'];
		  const idxSubSystem = col['sub system'];	//Could it be 'system' column instead
          
		  // Columns for digital alarms
          const idxID  = col['id'];
		  const idxInv = col['inv'];
          const idxAlarmConfig = col['alarmconfig'];
          const idxAlarmDelay  = col['alarmdelay'];
		  
		  // Columns for analog alarms
          const idxIDA = col['ida'];
		  const idxCondition = col['condition'];
		  const idxDeadband = col['deadband'];
		  
		  const idxAlarmConfigLL  = col['en'];
          const idxLowLowLimit = col['lowlowlimit'];
          const idxLowLowDelay = col['lowlowdelay'];
		  
		  const idxAlarmConfigL = col['en2'];
          const idxLowLimit = col['lowlimit'];
          const idxLowDelay = col['lowdelay'];
          
		  const idxAlarmConfigH = col['en3'];
		  const idxHighLimit = col['highlimit'];
          const idxHighDelay = col['highdelay'];
		  
		  const idxAlarmConfigHH = col['en4'];
          const idxHighHighLimit = col['highhighlimit'];
          const idxHighHighDelay = col['highhighdelay'];
		  
		  // Columns for scaling
		  const idxRawZero     = col['rawzero'];
		  const idxRawFull     = col['rawfull'];
		  const idxScaledZero  = col['scaledzero'];
		  const idxScaledFull  = col['scaledfull'];

		  // Columns for .tmc file
		  const idx1 = col['id1'];
		  const idx2 = col['id2'];
		  const idx3 = col['id3'];
		  const idx4 = col['id4'];
		  const idxDigSeverity = col['digital alarm severity'];
		  const xmlEscapeAttr = (s) => this.xmlEscape(s ?? '').replace(/\"/g, '&quot;');
		  const tmcEvent = (id, eventName, displayName, severity, systemValue) => {
		    const idAttr = xmlEscapeAttr(String(id ?? '').trim());
		    const disp = String(displayName ?? '').trim();
		    const sev = String(severity ?? '').trim();
		    const sys = this.xmlEscape(String(systemValue ?? '').trim());
		    return (`			<EventId>
				<Name Id="${idAttr}">${eventName}</Name>
				<DisplayName TxtId=""><![CDATA[${disp}]]></DisplayName>
				<Severity>${sev}</Severity>
				<Properties>
					<Property>
						<Name>System</Name>
						<Value>${sys}</Value>
					</Property>
				</Properties>
			</EventId>`
		    );
		  };
		  const tmcDigitalEvents = [];
		  const tmcAnalogEvents  = [];
		  
		  //Other
		  const producedTags = new Set();

			// -----------------------------------------------------------------------------
			// Build IO_Tags and VariableScale outputs.
			// The IO_Tags text is emitted in two sections:
			// 1) All base IO tag declarations
			// 2) All ST_AI instances (st_<TAG>) for HMI-enabled rows
			// -----------------------------------------------------------------------------
			const ioTagDeclLines = [];
			const stAiDeclLines = [];
			const scalingLines = [];

			for (const r of dataRows) {
			  const controlCell = (idxControl !== undefined) ? toStrTrim(r[idxControl]) : '';
			  const isControl = (controlCell.trim().toLowerCase() === 'x');

			  const hmiCell = (idxHMI !== undefined) ? toStrTrim(r[idxHMI]) : '';
			  const isHmi = (hmiCell.trim().toLowerCase() === 'x');

			  // Process rows that are either Control or HMI.
			  if (!isControl && !isHmi) continue;

			  const tag = toStrTrim(r[idxNAME]);
			  if (!tag) continue;

			  const tagLower = tag.toLowerCase();
			  if (tagLower === 'spare_di' || tagLower === 'spare_do' || tagLower === 'spare_ai' || tagLower === 'spare_ao') continue;

			  let atDecl = '';
			  if (tag.endsWith('_DI'))      atDecl = 'AT %I* : BOOL';
			  else if (tag.endsWith('_DO')) atDecl = 'AT %Q* : BOOL';
			  else if (tag.endsWith('_AI')) atDecl = 'AT %I* : INT';
			  else if (tag.endsWith('_AO')) atDecl = 'AT %Q* : INT';

			  const hwDecl = (idxHardwareDecl !== undefined) ? toStrTrim(r[idxHardwareDecl]) : '';
			  const comment = (idxComment !== undefined) ? toStrTrim(r[idxComment]) : '';
			  const commentSuffix = comment ? ` // ${comment}` : '';

			  // Base IO_Tags declarations (kept together).
			  if (hwDecl) ioTagDeclLines.push(hwDecl);
			  ioTagDeclLines.push(`${tag} ${atDecl};${commentSuffix}`);

			  // HMI-related declarations and scaling program (kept together, but stored separately).
			  if (isHmi) {
				const stVar = `st_${tag}`;

				const rawZero    = fmtNumberOrRaw((idxRawZero    !== undefined) ? r[idxRawZero]    : null, 0);
				const rawFull    = fmtNumberOrRaw((idxRawFull    !== undefined) ? r[idxRawFull]    : null, 0);
				const scaledZero = fmtNumberOrRaw((idxScaledZero !== undefined) ? r[idxScaledZero] : null, 0);
				const scaledFull = fmtNumberOrRaw((idxScaledFull !== undefined) ? r[idxScaledFull] : null, 0);

				stAiDeclLines.push(
				  `${stVar}: ST_AI := (RawZero:=${rawZero}, RawFull:=${rawFull}, ScaledZero:=${scaledZero}, ScaledFull:=${scaledFull});`
				);

				scalingLines.push(`${stVar}.Raw := ${tag}; ${stVar}.Scaled := FAiScale(${stVar});`);
			  }
			producedTags.add(tag);
			}

			// Final formatting: first IO tags, then ST_AI instances.
			const separator = (stAiDeclLines.length > 0) ? '\n\n' : '';
			this.tagsText = 
			`{attribute 'global_init_slot' := '40500'}\n` +
			`VAR_GLOBAL\n` +
			`//IO tags\n` +
			ioTagDeclLines.join('\n') + separator + 
			`//Analog tag scalings\n` +
			stAiDeclLines.join('\n') +
			`\nEND_VAR`
			
			this.variableScalingProgram = scalingLines.join('\n').trim();
			
			this.tags = [...producedTags];


          // Alarm_tags
          const digitalAlarmLines = [];
          const analogAlarmLines = [];

          // TwinCAT Declarations
          const fbDeclDigital = [];
          const fbDeclAnalog = [];
          const eventDeclDigital = [];
          const eventDeclAnalog = [];

          // TwinCAT Program
          const programFbLines = [];
          const programCreateExLines = [];

          const typeErrors = [];
		  let maxID = null;
		  let maxIDA = null;

		  for (const [i, r] of dataRows.entries()) {
		    const tag = toStrTrim(r[idxNAME]);
		    if (!tag) continue;
		    if (!isAlarmMark(r[idxAlarm])) continue;
		  
		    // Fila real del Excel (1-based)
		    const excelRow = startDataIndex + 1 + i;	
		  
		    const typeRaw = toStrTrim(r[idxTYPE]);
		    if (!typeRaw) {
		  	typeErrors.push(`Row ${excelRow}: 'TYPE' column is empty (${tag})`);
		  	continue; // no generes nada para esta alarma
		    }
		  
		    const typeUpper = typeRaw.toUpperCase();
		    const isDigital = typeUpper.includes('DIGITAL');
		    const isAnalog  = !isDigital; // todo lo que NO contenga DIGITAL => INT (analógica)
			
			// .tmc
			const almName = (idxALMNAME !== undefined) ? toStrTrim(r[idxALMNAME]) : '';
			const sysCell = (idxSubSystem !== undefined) ? toStrTrim(r[idxSubSystem]) : ((idxSubSystem !== undefined) ? toStrTrim(r[idxSubSystem]) : '');				
			
            // Alarm_tags generation
            if (isDigital) {
              const idCell = (idxID !== undefined) ? toStrTrim(r[idxID]) : '';
			  const idNum = Number(idCell);
			  if (Number.isFinite(idNum)) maxID = (maxID === null) ? idNum : Math.max(maxID, idNum);
			  
			  const id = fmtNumberOrRaw(idxID !== undefined ? r[idxID] : '', '0');
              const almName = toStrTrim(idxALMNAME !== undefined ? r[idxALMNAME] : '');
              const alarmConfig = fmtNumberOrRaw(idxAlarmConfig !== undefined ? r[idxAlarmConfig] : '', '0');
              const alarmDelay  = fmtNumberOrRaw(idxAlarmDelay !== undefined ? r[idxAlarmDelay] : '', '0');
			  
			  const id1 = (idx1 !== undefined) ? toStrTrim(r[idx1]) : '';
			  const sev = (idxDigSeverity !== undefined) ? toStrTrim(r[idxDigSeverity]) : 'Warning'; // default
              if (id1) {
			    tmcDigitalEvents.push(
				  tmcEvent(id1, `Event_${tag}`, almName, sev, sysCell)
				);
			  }
			  
			  digitalAlarmLines.push(
                `st_al_${tag}: ST_ALARM_DI := (ID:=${id}, Tag:='${tag}', TagInfo:='${almName}', AlarmConfig:=${alarmConfig}, AlarmDelay:=${alarmDelay}, Snooze:=0);`
              );
            }

            if (isAnalog) {
              const idaCell = (idxIDA !== undefined) ? toStrTrim(r[idxIDA]) : '';
			  const idaNum = Number(idaCell);
			  if (Number.isFinite(idaNum)) maxIDA = (maxIDA === null) ? idaNum : Math.max(maxIDA, idaNum);

			  const ida = fmtNumberOrRaw(idxIDA !== undefined ? r[idxIDA] : '', '0');
              const almName = toStrTrim(idxALMNAME !== undefined ? r[idxALMNAME] : '');
              const alarmConfig = fmtNumberOrRaw(idxAlarmConfig !== undefined ? r[idxAlarmConfig] : '', '0');

              const deadband = fmtNumberOrRaw(idxDeadband !== undefined ? r[idxDeadband] : '', '0');
              const lowLowLimit = fmtNumberOrRaw(idxLowLowLimit !== undefined ? r[idxLowLowLimit] : '', '0');
              const lowLowDelay = fmtNumberOrRaw(idxLowLowDelay !== undefined ? r[idxLowLowDelay] : '', '0');
              const lowLimit = fmtNumberOrRaw(idxLowLimit !== undefined ? r[idxLowLimit] : '', '0');
              const lowDelay = fmtNumberOrRaw(idxLowDelay !== undefined ? r[idxLowDelay] : '', '0');
              const highLimit = fmtNumberOrRaw(idxHighLimit !== undefined ? r[idxHighLimit] : '', '0');
              const highDelay = fmtNumberOrRaw(idxHighDelay !== undefined ? r[idxHighDelay] : '', '0');
              const highHighLimit = fmtNumberOrRaw(idxHighHighLimit !== undefined ? r[idxHighHighLimit] : '', '0');
              const highHighDelay = fmtNumberOrRaw(idxHighHighDelay !== undefined ? r[idxHighHighDelay] : '', '0');
			  const alarmConfigLL = enToConfig(idxAlarmConfigLL  !== undefined ? r[idxAlarmConfigLL]  : '', alarmConfig);
			  const alarmConfigL  = enToConfig(idxAlarmConfigL !== undefined ? r[idxAlarmConfigL] : '', alarmConfig);
			  const alarmConfigH  = enToConfig(idxAlarmConfigH !== undefined ? r[idxAlarmConfigH] : '', alarmConfig);
			  const alarmConfigHH = enToConfig(idxAlarmConfigHH !== undefined ? r[idxAlarmConfigHH] : '', alarmConfig);
			  const condRaw = (idxCondition !== undefined) ? toStrTrim(r[idxCondition]) : '';
			  const bCondition = condRaw ? condRaw : '1';
			  
			  // .tmc
			  const id1 = (idx1 !== undefined) ? toStrTrim(r[idx1]) : '';
			  const id2 = (idx2 !== undefined) ? toStrTrim(r[idx2]) : '';
			  const id3 = (idx3 !== undefined) ? toStrTrim(r[idx3]) : '';
			  const id4 = (idx4 !== undefined) ? toStrTrim(r[idx4]) : '';
			  
			  if (id1) tmcAnalogEvents.push(tmcEvent(id1, `EventHH_${tag}`, `${almName} high high`, 'Critical', sysCell));
			  if (id2) tmcAnalogEvents.push(tmcEvent(id2, `EventH_${tag}`,  `${almName} high`,      'Warning',  sysCell));
			  if (id3) tmcAnalogEvents.push(tmcEvent(id3, `EventL_${tag}`,  `${almName} low`,       'Warning',  sysCell));
			  if (id4) tmcAnalogEvents.push(tmcEvent(id4, `EventLL_${tag}`, `${almName} low low`,   'Critical', sysCell));
  
              analogAlarmLines.push(
                `st_al_${tag}: ST_ALARM_AI := (` +
                  `ID:=${ida}, ` +
                  `TAG:='${tag}', ` +
                  `bCondition:=${bCondition}, ` +
				  `ScaledMax:=st_${tag}.ScaledFull, ` +
                  `TagInfo:='${almName}', ` +
                  `AlarmConfigLL:=${alarmConfigLL}, AlarmConfigL:=${alarmConfigL}, AlarmConfigH:=${alarmConfigH}, AlarmConfigHH:=${alarmConfigHH}, ` +
                  `Deadband:=${deadband}, ` +
                  `LowLowLimit:=${lowLowLimit}, LowLowDelay:=${lowLowDelay}, ` +
                  `LowLimit:=${lowLimit}, LowDelay:=${lowDelay}, ` +
                  `HighLimit:=${highLimit}, HighDelay:=${highDelay}, ` +
                  `HighHighLimit:=${highHighLimit}, HighHighDelay:=${highHighDelay}` +
                `);`
              );
            }

            // Declarations (FB instances)
            if (isDigital) fbDeclDigital.push(`fb_${tag}: FB_DI;`);
            if (isAnalog)  fbDeclAnalog.push(`fb_${tag}: FB_AI;`);

            // Declarations (Event FBs)
            if (isDigital) {
              eventDeclDigital.push(`Event_${tag}: FB_TcAlarm;`);
            }
            if (isAnalog) {
              eventDeclAnalog.push(`EventL_${tag}: FB_TcAlarm;`);
              eventDeclAnalog.push(`EventLL_${tag}: FB_TcAlarm;`);
              eventDeclAnalog.push(`EventH_${tag}: FB_TcAlarm;`);
              eventDeclAnalog.push(`EventHH_${tag}: FB_TcAlarm;`);
            }

            // Program (FB calls + CreateEx init)
            const invMark = (idxInv !== undefined) ? toStrTrim(r[idxInv]).toLowerCase() : '';
            const isInverted = (invMark === 'x');

            const subSystemRaw = (idxSubSystem !== undefined) ? toStrTrim(r[idxSubSystem]) : '';
            const subSystemExpr = subSystemRaw ? `SubSystem_${toIdentifier(subSystemRaw)}` : '0';

            if (isDigital) {
              const varExpr = isInverted ? `NOT ${tag}` : `${tag}`;

              programFbLines.push(
                `fb_${tag}(i_bVariable:=${varExpr}, i_bConfig:=bAlarmSetupActive, ST_Variable:=st_al_${tag}, FB_Alarm:=Event_${tag});`
              );

              programCreateExLines.push(
                `Event_${tag}.CreateEx(TC_Events.AlarmClass.Event_${tag}, TRUE, ${subSystemExpr});`
              );
            }

            if (isAnalog) {
              programFbLines.push(
                `fb_${tag}(i_nVariable:=st_${tag}.Scaled, i_bConfig:=bAlarmSetupActive, ST_Variable:=st_al_${tag}, ` +
                `FB_LowAlarm:=EventL_${tag}, FB_LowLowAlarm:=EventLL_${tag}, FB_HighAlarm:=EventH_${tag}, FB_HighHighAlarm:=EventHH_${tag});`
              );

              programCreateExLines.push(
                `EventL_${tag}.CreateEx(TC_Events.AlarmClass.EventL_${tag}, TRUE, ${subSystemExpr});`
              );
              programCreateExLines.push(
                `EventLL_${tag}.CreateEx(TC_Events.AlarmClass.EventLL_${tag}, TRUE, ${subSystemExpr});`
              );
              programCreateExLines.push(
                `EventH_${tag}.CreateEx(TC_Events.AlarmClass.EventH_${tag}, TRUE, ${subSystemExpr});`
              );
              programCreateExLines.push(
                `EventHH_${tag}.CreateEx(TC_Events.AlarmClass.EventHH_${tag}, TRUE, ${subSystemExpr});`
              );
            }
          }
		  
		  this.maxID  = maxID;
		  this.maxIDA = maxIDA;
		  
		  if (typeErrors.length) {
		    this.alarmDigitalText = '';
		    this.alarmAnalogText = '';
		    this.alarmTagsText = '';
		    this.alarmsTwinCatDeclaration = '';
		    this.alarmsTwinCatProgram = '';
			this.tmcDigitalEventsText = '';
			this.tmcAnalogEventsText  = '';
		    this.debug = 'Error: ' + typeErrors.join('\n');
		  return;
		  }
		  
		  // .tmc
		  this.tmcDigitalEventsText = tmcDigitalEvents.join('\n');
		  this.tmcAnalogEventsText  = tmcAnalogEvents.join('\n')
  
          // Fill Alarm_tags boxes data
          this.alarmDigitalText = digitalAlarmLines.join('\n');
          this.alarmAnalogText = analogAlarmLines.join('\n');
			
          // Combined Alarm_tags for one single textarea
          this.alarmTagsText =
`{attribute 'global_init_slot' := '40502'}
VAR_GLOBAL PERSISTENT
${this.alarmDigitalText || ''}${(this.alarmDigitalText && this.alarmAnalogText) ? '\n\n' : ''}${this.alarmAnalogText || ''}
END_VAR

VAR_GLOBAL CONSTANT
///Digital alarm array size
ArrMinD: INT := 1;
ArrMaxD: INT := ${maxID ?? '-' };
///Analog alarm array size
ArrMinA: INT := 1;
ArrMaxA: INT := ${maxIDA ?? '-' };
END_VAR

VAR_GLOBAL
///Array needs to be at least as big as the highest digital struct ID
Arr_AlarmDigital: ARRAY[ArrMinD..ArrMaxD] OF ST_ALARM_DI;
///Array needs to be at least as big as the highest analog struct ID
Arr_AlarmAnalog: ARRAY[ArrMinA..ArrMaxA] OF ST_ALARM_AI;
END_VAR`.trim() + '\n';

          // TwinCAT declarations
          this.alarmsTwinCatDeclaration =
`PROGRAM Alarms
VAR
${fbDeclDigital.join('\n')}${fbDeclDigital.length ? '\n' : ''}${fbDeclAnalog.join('\n')}

${eventDeclDigital.join('\n')}${eventDeclDigital.length ? '\n' : ''}${eventDeclAnalog.join('\n')}

//Other tags	
	fbEventlogger: FB_TcEventLogger;
	bSilence: BOOL;
	bTemp: BOOL;
	i: INT;
	o_bBuzzerD: BOOL;
	o_bBuzzerA: BOOL;
	o_bAlarmLightD: BOOL;
	o_bAlarmLightA: BOOL;
	bTempA: BOOL;
	fbSRLight: RS;
	fbTRIGLight: R_TRIG;
	bIsInitalized: BOOL;
	bConfirm: BOOL;
	bConfirmAll: BOOL;
	bAlarmSetupActive: BOOL;
	bClearAll: BOOL;
	bDigitalCounter: INT;
	bAnalogCounter: INT;
END_VAR`.trim() + '\n';

          // TwinCAT program
          const createExIndented = programCreateExLines.map(l => `    ${l}`).join('\n');

          this.alarmsTwinCatProgram =
`{attribute 'global_init_slot' := '40503'}
IF NOT bIsInitalized THEN
    bIsInitalized := TRUE;
{region "Events"}	// Digital events
${createExIndented}
{endregion}
END_IF

{region "Alarms"}	// Alarm functions
${programFbLines.join('\n')}
{endregion}
`.trim() + '\n';

		  // .tmc file generation
		  this.tmcText =
			this.tplTmcHeader +
			tmcDigitalEvents.join('\n') + '\n' +
			tmcAnalogEvents.join('\n') + '\n' +
			this.tplTmcFooter;
		  
          // Debug
          const missing = [];
          const must = (key, label) => { if (col[key] === undefined) missing.push(label); };
          must('hardware declaration', 'Hardware declaration (optional)');
          must('comment', 'Comment (optional)');
          must('inv', 'Inv (optional, for NOT)');
          must('sub system', 'Sub system (optional, for CreateEx)');

          this.debug =
            `Header row used: ${headerRowIndex + 1}\n` +
            `Data start row: ${startDataIndex + 1}\n` +
            `Total tags: ${this.tags.length}\n` +
            `Digital alarms: ${maxID}\n` +
            `Analog alarms: ${maxIDA}\n`;
            //`PROGRAM FB calls: ${programFbLines.length}\n` +
            //`PROGRAM CreateEx calls: ${programCreateExLines.length}\n` +
            //`Missing optional columns (if any): ${missing.length ? missing.join(', ') : 'none'}\n`;
        }
      }
    }).mount('#app');
  </script>
</body>
</html>
